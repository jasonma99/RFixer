import glob
import os
import json
import numpy as np
import random
import string
import exrex
import rstr
import re
import Levenshtein

# Patterns that could be randomly generated
patterns = ["\d", "\w", "#", "char", "{#}", "{#,#}", "#-#", "char-char", "?"]
lower = string.ascii_lowercase
upper = string.ascii_uppercase
alphabet = string.ascii_letters
# used in generate_deletion(), check_replacement(), check_insertion(), 
quantifiers = ["{", "+", "*", "?"]
precedents = ["{", "[", "(", "|", "+", "*", "?"]


def generate_positives(gt_regex, total_examples):
    """
    This function generates a number of positive examples using ground truth regex and return the list of examples.

    :param gt_regex: the ground truth regex used to generate examples.
    :param num: number of positive examples to generate.
    :return: a list of positive examples generated from ground truth regex.
    """

    positives = []
    for i in range(total_examples):
        positives.append(rstr.xeger(gt_regex)+"\n")
    return positives


def generate_negative_example(ini_regex, gt_regex, negatives, num, num_neg, counter_break, final_regex):
    """
    This function use ini_regex to generate a number of negative examples, append each example that does not match with gt_regex to the list `negatives`. Break out of the while loop when the counter reaches the maximum number iterations or len(negatives) == num_neg.

    :param ini_regex: the initial regex used to generate examples
    :param gt_regex: the ground truth regex used to check if the negative example generated from ini_regex could be matched with gt_regex
    :param negatives: the list of negative examples to append to.
    :param num: the number of negative examples generated by ini_regex.
    :param num_neg: total number of negative examples to generate.
    :param counter_break: the max number of iterations to generate examples.
    :param final_regex: [0] is the final ini_regex to put into the test file.
    """

    print(f"Generate negative: {ini_regex}, {gt_regex}")
    i = 0
    counter = 0
    while i <= num:
        neg = rstr.xeger(ini_regex)
        # add to negatives only if the example does not match with gt_regex
        if not re.fullmatch(gt_regex, neg):
            negatives.append(neg + "\n")
            i += 1
        counter += 1
        if counter == counter_break or len(negatives) == num_neg:
            return
    final_regex[0] = ini_regex


def parse_gt_regex(gt_regex):
    """
    Parse the ground truth regex and save the parsed elements to a list: contents; save changeable indices to a list: changeable.

    changeable elements: #-#, char-char, #, char, \d, \w, {#}, {#, #}, +, *, |, ?

    :param gt_regex: the ground truth regex to parse.
    :return contents: the list of parsed ground truth regex elements.
    :return changeable: the indices of changeable elements of the contents list.

    i.e: gt_regex = [0-3a-g]a\d{3}-\d{4}-\d
    contents: ['[', '0-3', 'a-g', ']', 'a', '\d', '{3}', '-', '\d', '{4}', '-', '\d']
    changeable: [1, 2, 4, 5, 6, 8, 9, 11]
    """

    contents = []
    changeable = []
    # index of ground truth regex characters
    i = 0
    # index of contents elements
    index = 0
    while i < len(gt_regex):
        if gt_regex[i] == '\\':
            # \d, \w
            item = gt_regex[i:i+2]
            contents.append(item)
            changeable.append(index)
            i += 1
        elif gt_regex[i].isdigit():
            # #-# or #
            if re.match("-\d", gt_regex[i+1:i+3]):
                item = gt_regex[i:i+3]
                i += 2
            else:
                item = gt_regex[i]
            contents.append(item)
            changeable.append(index)
        elif gt_regex[i].isalpha():
            # char-char or char
            if re.match("-[a-zA-Z]", gt_regex[i+1:i+3]):
                item = gt_regex[i:i+3]
                i += 2
            else:
                item = gt_regex[i]
            contents.append(item)
            changeable.append(index)
        elif gt_regex[i] == "{":
            # {#} or {#, #}
            j = i
            while gt_regex[j]!= "}":
                j += 1
            item = gt_regex[i:j+1]
            contents.append(item)
            changeable.append(index)
            i = j
        elif gt_regex[i] in ("+", "*", "?", "|"):
            contents.append(gt_regex[i])
            changeable.append(index)
        else:
            # not changeable elements, just append to contents
            contents.append(gt_regex[i])
        index += 1
        i += 1
    return contents, changeable


def generate_deletion(contents, changeable):
    """
    Randomly remove a changeable item from contents using changeable indices `changeable`. 
    quantifiers = ["{", "+", "*", "?"]
    precedents = ["{", "(", "[", "|", "+", "*", "?"]
    Special Cases: 
        1. Remove if the index is the last index of contents.
        2. When the index is followed by a quantifier:
            - do not remove if index == 0
            - do not remove if the index is leaded by any of precedents
        3. Do not remove when the index is the only element in a character class. [index]

    :param contents: the list of parsed ground truth regex elements.
    :param changeable: the indices of changeable elements of the contents list.
    :return: modified contents and changeable list.
    """

    acceptable = False
    while not acceptable:
        remove_index = random.choice(changeable)
        # Remove if the index is the last index of contents
        if remove_index == len(contents)-1:
            acceptable = True
            break
        # check before delete item followed by a quantifier
        elif any(c in contents[remove_index+1] for c in quantifiers):
            # for item{#} or precedencts appear before item
            if remove_index == 0 or any(c in contents[remove_index-1] for c in precedents):
                acceptable = False
            else:
                acceptable = True
        # for [item], cannot remove it
        elif '[' == contents[remove_index-1] and ']' == contents[remove_index+1]:
            acceptable = False
        else:
            acceptable = True

    # minus one for all changeable indices to the right of the remove index
    index = changeable.index(remove_index)
    for i in range(index+1, len(changeable)):
        changeable[i] -= 1
    # remove the remove_index from changeable
    changeable.remove(remove_index)
    removed = contents.pop(remove_index)
    # print(f"removed '{removed}' from index {remove_index}")
    return contents, changeable


def generate_phrase():
    """
    Randomly select a pattern to generate a phrase for replacement or insertion. 
    Patterns that could be randomly generated: ["\d", "\w", "#", "char", "{#}", "{#,#}", "#-#", "char-char", "?"]
    
    :return the randomly selected pattern and phrase.
    """
    cases = ["lower", "upper"]
    pattern = random.choice(patterns)
    if pattern == "#-#":
        first = random.randint(0, 9)
        second = random.randint(first, 9)
        phrase = f"{first}-{second}"
    elif pattern == "char-char":
        first = random.randint(0, 25)
        second = random.randint(first, 25)
        if random.choice(cases) == "lower":
            phrase = f"{lower[first]}-{lower[second]}"
        else:
            phrase = f"{upper[first]}-{upper[second]}"
    elif pattern in ("\d", "\w", "?"):
        phrase = pattern
    elif pattern == "{#}":
        phrase = "{" + str(random.randint(1, 9)) + "}"
    elif pattern == "{#,#}":
        first = random.randint(1, 9)
        second = random.randint(first, 9)
        phrase = "{" + f"{first},{second}" + "}"
    elif pattern == "#":
        phrase = f"{random.randint(0, 9)}"
    elif pattern == "char":
        phrase = f"{random.choice(alphabet)}"
    return pattern, phrase


def check_replacement(pattern, phrase, contents, index):
    """
    Check if the phrase is acceptable to replace contents[index].
    quantifiers = ["{", "+", "*", "?"]
    precedents = ["{", "(", "[", "|", "+", "*", "?"]
    Special Cases:
        1. When the pattern is {#}, {#,#}, ?
            - not acceptable if index is 0, or the index is leaded by any of precedents.
            - acceptable if index is the last index of contents
            - not acceptable if the index is followed by a quantifier.
        2. When the contents[index] is # or #-# or \d, don't replace it with a "#" or "#-#" or "\d".
        3. When the contents[index] is "char" or "char-char" or \w, don't replace it with a "char" or "char-char" or \w.

    :param pattern: the pattern of the randomly generated phrase.
    :param phrase: the phrase to replace.
    :param contents: the list of parsed ground truth regex elements.
    :param index: the replacement index of contents.
    :return: True if it is acceptable to replace phrase at contents[index]
    """
    element = contents[index]
    if pattern in ("{#}", "{#,#}", "?"):
        # cannot replace: index is 0, any of {}, (, |, +, *, ? appear before index
        if index == 0 or any(c in contents[index-1] for c in precedents):
            return False
        elif index == len(contents)-1:
            return True
        # quantifiers after index
        elif any(c in contents[index+1] for c in quantifiers):
            return False
    # if the content is a "#" or "#-#" or "\d", don't replace it with a "#" or "#-#" or "\d"
    elif re.match("[0-9]", element) or re.match("[0-9]-[0-9]", element) or re.match("\\\\d", element):
        if pattern in ("#", "#-#", "\d"):
            return False
    # if the content is a "char" or "char-char", don't replace it with a "char" or "char-char"
    elif re.match("[a-zA-Z]", element) or re.match("[a-zA-Z]-[a-zA-Z]", element) or re.match("\\\\w", element):
        if pattern in ("char", "char-char", "\w"):
            return False
    return True

def check_insertion(pattern, phrase, contents, index):
    """
    Check if the phrase is acceptable to insert at contents[index].
    quantifiers = ["{", "+", "*", "?"]
    precedents = ["{", "(", "[", "|", "+", "*", "?"]
    Special Cases:
        1. When the pattern is {#}, {#,#}, ?
            - not acceptable if index is 0, or the index is leaded by any of precedents.
            - not acceptable if the index is a quantifier.

    :param pattern: the pattern of the randomly generated phrase.
    :param phrase: the phrase to insert.
    :param contents: the list of parsed ground truth regex elements.
    :param index: the replacement index of contents.
    :return: True if it is acceptable to insert phrase at contents[index]
    """
    if pattern in ("{#}", "{#,#}", "?"):
        # cannot insert: index is 0, any of {}, (, [, |, +, *, ? appear before index
        if index == 0 or any(c in contents[index-1] for c in precedents):
            return False
        # quantifiers after index
        elif any(c in contents[index] for c in quantifiers):
            return False
    elif (contents[index-1]=="[" and contents[index]== "-") or (contents[index-1]=="-" and contents[index]=="]"):
        return False
    return True


def generate_replacement(contents, changeable):
    """
    This function randomly select an index from changeable to replace, randomly generate a phrase to replace, check `check_replacement()` and replace.

    :param contents: the list of parsed ground truth regex elements.
    :param changeable: the indices of changeable elements of the contents list.
    :return: modified contents.
    """
    while True:
        # randomly select an index to replace
        index = random.choice(changeable)
        # randomly generate the phrase to replace
        pattern, phrase = generate_phrase()
        # replace only when the check is passed
        if check_replacement(pattern, phrase, contents, index):
            origin = contents[index]
            contents[index] = phrase
            break
    # print(f"replaced '{origin}' by '{phrase}'")
    return contents


def generate_insertion(contents, changeable):
    """
    This function randomly select an index from changeable to insert, randomly generate a phrase to insert, check `check_insertion()` and replace.

    :param contents: the list of parsed ground truth regex elements.
    :param changeable: the indices of changeable elements of the contents list.
    :return: modified contents.
    """
    while True:
        # randomly select an index to insert
        index = random.choice(changeable)
        # randomly generate the phrase to insert
        pattern, phrase = generate_phrase()
        # insert only when the check is passed
        if check_insertion(pattern, phrase, contents, index):
            contents.insert(index, phrase)
            break
    # print(f"insert '{phrase}' at index {index}")
    return contents


def generate_ini_regex(gt_regex, num, N, num_neg, random_examples, error_type_ratio, tolerance, counter_break):
    """
    - Within a loop, run operations to generate initial regex and use it to generate `num` negative examples, until we have enough negative examples.
    - A proportion of `error_type_ratio[0]` of the number of changeable elements will perform operations. There are 3 types of operations with ratio defined by `error_type_ratio[1:3]`.
    - Use initial regex to generate negative examples only if the Levenshtein distance between ground truth regex and initial regex is within a threshold: `tolerance`.
    - After we have enough negative examples, generate random strings of `N` characters, the number of random strings is `random_examples`.
    
    :param gt_regex: the ground truth regex.
    :param num: the number of negative examples to generate by ini_regex.
    :param N: the length of randomly generated string.
    :param num_neg: total number of negative examples to generate.
    :param random_eamples: the number of random strings.
    :param error_type_ratio: [ratio of operations on changeable, ratio deletion, ratio replacement, ratio insertion]
    :param tolerance: the tolerance threshold of Levenshtein distance between gt_regex and ini_regex
    :param counter_break: the max number of iterations to generate examples.
    :return the initial regex and negative examples.
    """

    final_regex = [""]
    negatives = []
    contents, changeable = parse_gt_regex(gt_regex)
    num_operations = int(error_type_ratio[0] * len(changeable))
    num_deletion = 0
    # do not run deletion when changeable elements is < 3
    if num_operations < 3:
        num_replacement = 1
        num_insertion = 1
    else:
        num_deletion = int(error_type_ratio[1] * num_operations)
        num_replacement = int(error_type_ratio[2] * num_operations)
        num_insertion = int(error_type_ratio[3] * num_operations)
    print(f"num deletion: {num_deletion}, num replacement: {num_replacement}, num insertion: {num_insertion}")

    while len(negatives) < num_neg:
        contents, changeable = parse_gt_regex(gt_regex)
        for i in range(num_deletion):
            contents, changeable = generate_deletion(contents, changeable)
        for i in range(num_replacement):
            contents = generate_replacement(contents, changeable)
        for i in range(num_insertion):
            contents = generate_insertion(contents, changeable)

        ini_regex = ''.join(contents)
        # generate negative examples only if it pass the distance check
        if check_Levenshtein(gt_regex, ini_regex, tolerance):
            generate_negative_example(ini_regex, gt_regex, negatives, num, num_neg, counter_break, final_regex)

    # generate random negative examples
    for i in range(random_examples):
        neg = ''.join(random.choices(alphabet + string.digits, k = N))
        negatives.append(neg + "\n")
    return final_regex[0], negatives

 
def check_Levenshtein(gt_regex, ini_regex, tolerance):
    """
    check if the Levenshtein distance between ini_regex and ground truth regex is within the tolerance.

    :param gt_regex: the ground truth regex.
    :param ini_regex: the initial regex.
    :param tolerance: the tolerance threshold of Levenshtein distance between gt_regex and ini_regex
    :return: true if within tolerance, otherwise false.
    """
    return Levenshtein.distance(gt_regex, ini_regex) <= tolerance


def write_file(filename, ini_regex, positives, negatives):
    """
    Write to test file with the following format:
    ini_regex
    +++
    positive examples
    ---
    negative examples
    """
    with open(filename, "w") as outfile:
        outfile.write(ini_regex+"\n")
        outfile.write("+++\n")
        outfile.writelines(positives)
        outfile.write("---\n")
        outfile.writelines(negatives)


def main():
    # glob detectors_config.json files
    data_list = glob.glob("tests/detectors/*/detector_config.json")
    data_list.sort()
    # folder to generate test files
    tests_dir = "tests/dataset_160/"
    if not os.path.isdir(tests_dir):
        os.mkdir(tests_dir)
    # save file name and gt_regex to a text file
    regex_file = open("tests/dataset_160.txt", "w")

    ####################################################################################################
    # configurations:
    # number of examples to generate
    total_examples = 160
    # tolerance threshold of Levenshtein distance between gt_regex and ini_regex
    tolerance = 100
    # [ratio of operations on changeable, ratio deletion, ratio replacement, ratio insertion]
    error_type_ratio = [0.5, 1/3, 1/3, 1/3]
    # ratio of random examples in neg examples
    random_ratio = 0.2
    num_neg = int(total_examples * ( 1 - random_ratio ))
    random_examples = total_examples - num_neg
    # number of negative examples generated by each ini_regex 
    each_initial = 0.25
    num = int(each_initial * total_examples)
    # the length of randomly generated string
    N = 10
    # the max number of iterations to generate examples.
    counter_break = num * 3
    ####################################################################################################

    total_distance = 0
    for json_path in data_list:
        # use folder name as the test file name
        dir_name = os.path.basename(os.path.dirname(json_path))
        json_file = open(json_path)
        data = json.load(json_file)

        for i, gt_regex in enumerate(data["Complex Regex"]):
            # RFixer does not accept "\s" so filter out regex that contains "\s"
            if "\\s" in gt_regex:
                continue
            
            file_name = tests_dir + dir_name + f"_{i}.txt"
            print(f"{file_name}: {gt_regex}")

            # generate positive examples
            positives = generate_positives(gt_regex, total_examples)
            # generate ini_regex and negative examples
            ini_regex, negatives = generate_ini_regex(gt_regex, num, N, num_neg, random_examples, error_type_ratio, tolerance, counter_break)
            total_distance += Levenshtein.distance(gt_regex, ini_regex)

            # write to test file
            write_file(file_name, ini_regex, positives, negatives)
            regex_file.write(f"{dir_name}: {gt_regex}, {ini_regex}\n")
        json_file.close()
    avg_distance = total_distance / len(data_list)
    regex_file.write(f"\nAverage Levenshtein distance is: {avg_distance}.")
    regex_file.close()
    print(f"Average Levenshtein distance is: {avg_distance}.")


if __name__ == "__main__":
    main()